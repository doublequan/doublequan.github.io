<!DOCTYPE html>
<!--[if lt IE 7 ]>
<html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]>
<html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]>
<html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<html lang="en">
<!--<![endif]-->

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <!--[if IE]>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <![endif]-->
    <title>CStore: In-Memory Column-Oritented Data Store</title>
    <!--REQUIRED STYLE SHEETS-->
    <!-- BOOTSTRAP CORE STYLE CSS -->
    <link href="assets/css/bootstrap.css" rel="stylesheet"/>
    <link href="assets/css/bootflat.css" rel="stylesheet"/>
    <!-- FONTAWESOME STYLE CSS -->
    <link href="assets/css/font-awesome.min.css" rel="stylesheet"/>
    <!-- VEGAS STYLE CSS -->
    <link href="assets/scripts/vegas/jquery.vegas.min.css" rel="stylesheet"/>
    <!-- CUSTOM STYLE CSS -->
    <link href="assets/css/style.css" rel="stylesheet"/>
    <!-- GOOGLE FONT -->
    <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
</head>

<body>
<!--Header section  -->
<div class="container" id="home">
    <div class="row text-center">
        <div class="col-md-12">
            <h1 class="head-main">CStore: A Lock-free SIMD Skip List</h1>
            <h2 class="head-sub-main"></h2>
            <h3 class="head-last"><a href="">Ziyi Liu</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="">Quan Quan</a>
            </h3>
        </div>
    </div>
</div>
<!--End Header section  -->
<!-- Navigation -->
<nav class="navbar-inverse" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="#"> CStore</a>
        </div>
        <!-- Collect the nav links for toggling -->
        <div class="collapse navbar-collapse navbar-ex1-collapse pull-right">
            <ul class="nav navbar-nav">
                <li><a href="proposal.html">Proposal</a>
                </li>
                <!--<li><a href="proposal.html">PROPOSAL</a>-->
                <!--</li>-->
                <!--<li><a href="checkpoint.html">CHECKPOINT</a>-->
                <!--</li>-->
                <li><a href="index.html">FINAL REPORT DRAFT</a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<!--End Navigation -->
<!--About Section-->
<section class="for-full-back color-white " id="about">
    <div class="container introduction">
        <div class="row text-center">
            <div class="col-md-8 col-md-offset-2 ">
                <h1>Final Report Draft</h1>
                <!-- <h4>
                    <strong>
                   Lorem ipsum dolor sit amet, consectetur adipiscing elit.
                     Curabitur nec nisl odio. Mauris vehicula at nunc id posuere.
                        </strong>
                </h4> -->
            </div>
        </div>
        <div class="row g-pad-bottom">
            <div class="col-md-12">
                <h2> <a href="https://github.com/doublequan/doublequan.github.io/blob/master/CStoreFinalReport.pdf">Link to our final report</a> </h2>
                <h2>Summary</h2>
                <p>
                    In this project we implemented a lock-free skiplist which supports insert, delete and find.
                    It is different from traditional lock-free skiplist in a way that we divide the skiplist into the
                    index layer and storage layer, and apply SIMD to speed up the lookup process.
                </p>

                <center>
                    <img src="assets/img/F1.jpeg" alt="">
                    <br>
                    <b><big>Figure 1. Architecture of our SIMD skiplist</big></b>
                </center>

                <p>Above is a representation of the architecture of our skiplist. In the index layer, we group multiple
                    indexes of a node together in one index node, so we can make use of cache locality and use SIMD
                    comparison to get the routing decision in one run. The index layer will not change until some upper
                    limit of the number of inserts and deletes are triggered, in which case we will build a new index
                    layer to replace the old one. In the storage layer, we only have an ordered lock-free singly-linked
                    list.

                </p>
                <h2>Challenges</h2>
                <p><b><big>1. Refined lock-free skiplist.</big></b> In order to hava a good perfermance, we need to
                    build a lockfree sorted linkedlist to act as the storage layer. We referred to Harris’s solution[1]
                    of a lockfree sorted linkedlist: utilize CAS and a special mark on node’s next address to implement
                    the lockfree insert and lockfree deletion. The last digit of the next pointer is used to mark the
                    node is logical deleted. However, this is not enough in our case. Beside the storage layer, we still
                    have index layer which holds the pointers to the nodes in storage layer. If we physically delete the
                    node after a node is marked logical deleted as described in the paper[1], this will lead to
                    segmentation faults if the freed node is accessed. To address this, we introduced another flag which
                    we called it confirm_delete flag. This flag placed on the second last digit of a node’s next
                    pointer. The confirm_delete flag will only be set while rebuilding the new index layer. And after a
                    node is marked as confirm_delete, it will be physically deleted in later operations. </p>
                <p><b><big>2. Group indexes together for SIMD and better data locality.</big></b> One of the most
                    significant deficiency of skiplist is that it has poor data locality because the skip lists are
                    basically linked lists, and linked list nodes are scattered across the memory and have poor data
                    locality. To resolve this problem, we group multiple indexes together into a single index node, so
                    that we can use SIMD compares to get the routing result quicker, and make better use of data
                    locality since these indexes are in the same node. When building the index layer we pre-calculate
                    the routing table for each index node, so at each index node once we get the comparison result, we
                    know which node to go to.
                </p>
                <p><b><big>3. Rebuild index layer, and does not disturb serving the requests.</big></b> For the index
                    layer, because we are grouping multiple indexes on the same level to one single index node, this
                    makes
                    modifying it without using locks and frequent memory movement to be very hard. This leads us to
                    believe it is better to only build a new index layer and replace the old one at some interval.
                    Although it may hurt the performance a little bit, it saves us the difficulty to build a lock-free
                    index layer (because simply adding a lock or moving data in memory may hurt the performance even
                    further). Also, to ensure performance during the new index layer building stage, our skiplist will
                    not deny queries and will continue to use the old index layer to serve the requests. Once the new
                    index layer is built, it will replace the old index layer immediately.</p>

            </div>
        </div>
    </div>
</section>
<!--End About Section-->
<!-- About Team Section -->
<section class="for-full-back color-light challenge" id="about-team">
    <div class="container">
        <div class="row introduction">
            <div class="col-md-12">
                <h2 class="text-center">Results</h2>

                <h4>1. Benchmark on CStore with SIMD On/Off</h4>

                <p>
                    Here is the comparison of CStore’s performance with SIMD on and off with different thread numbers in
                    read-only scenario:
                </p>

                <center>
                    <img src="assets/img/fr1.jpeg" alt="">
                    <br>
                    <b><big>Table 2. Read-only Performance with ISPC On/Off</big></b>

                    <br>
                    <br>

                    <img src="assets/img/fr2.jpeg" alt="">
                    <br>
                    <b><big>Figure 2. Read-only Performance with ISPC On/Off</big></b>
                </center>

                <p>
                    We can see that with SIMD on, CStore’s performance perfectly grows with the number of threads. On
                    the other hands, with SIMD off, we have to compare the indexes one by one, so the performance is
                    significantly worse and is around 8 ~ 10 times slower than the implementation with SIMD on.
                </p>

                <center>
                    <img src="assets/img/fr3.png" alt="">
                    <br>
                    <b><big>Table 3. Mix Request Performance with ISPC On/Off</big></b>
                    <br>
                    (20% read, 60% write, 20% delete)

                    <br>
                    <br>

                    <img src="assets/img/fr4.jpeg" alt="">
                    <br>
                    <b><big>Figure 3. Mix Request Performance with ISPC On/Off</big></b>
                </center>

                <p>In the mix request scenario, the performance is similar. With SIMD on, the best performance is
                    slightly worse because of backoff from CAS operation failure in multi-threading scenario. With more
                    threads on, the performance gets even worse because of high contention.
                </p>


                <h4>2. Benchmark on CStore and Other O(logN) Lookup Data Structures</h4>

                <center>
                    <img src="assets/img/F3.jpeg" alt="">
                    <br>
                    <b><big>Table 4. Read-only Performance Between CStore, std map, Sequential Skiplist</big></b>

                    <br>
                    <br>

                    <img src="assets/img/F4.jpeg" alt="">
                    <br>
                    <b><big>Figure 4. Read-only Performance Between CStore, std map, Sequential Skiplist</big></b>
                </center>

                <p>
                    This is the performance comparison with std::map and normal sequential skiplist in read-only
                    situations, and these numbers show that CStore is about 2 times slower than std::map. This is
                    mostly because skiplist is based on probability model and if the index is not built perfectly,
                    it is expected to have worse performance than tree-based ordered data structure. However,
                    because of the speedup brought by SIMD and data locality, we are able to be about 8 ~ 10 times
                    faster than normal skiplists implemented by ourselves.
                </p>

                <p>MIX Request (Comparison with std::map(), locked by boost::shared_lock() and unique_lock())
                    with 60% read, 30% write, 10% delete, thread no.=16, tasks=3200000
                </p>

                <center>
                    <img src="assets/img/fr5.png" alt="">
                    <br>
                    <b><big>Table 5. Mix Requests Performance Between CStore and std map</big></b>

                    <br>
                    <br>

                    <img src="assets/img/fr6.jpeg" alt="">
                    <br>
                    <b><big>Figure 5. Mix Requests Performance Between CStore and std map</big></b>
                </center>

                <p>However, std::map is not thread-safe, and it is very hard to build lock-free red-black trees. For mix
                    reads we try to wrap the read and write operations of std::map with read-write lock from boost, in
                    this case CStore is about 30~40 times more performant than std::map.
                </p>

                <h4>3. Benchmark on CStore and Other Implementation of Lockfree Skiplist</h4>

                <p>
                    Now we want to compete with non-SIMD lock-free skiplists. We found this finely written lock-free
                    skiplist from the Internet and we use this as the competitor.
                </p>

                <center>
                    <img src="assets/img/fr7.png" alt="">
                    <br>
                    <b><big>Table 6. Read-only Performance Between CStore and Lock-free Skiplist</big></b>
                    <br>
                    (Thread Num 32, Total Tasks = 32,000,000)

                    <br>
                    <br>

                    <img src="assets/img/fr8.jpeg" alt="">
                    <br>
                    <b><big>Figure 6. Read-only Performance Between CStore and Lock-free Skiplist</big></b>
                </center>

                <p>In read-only scenario, we are generally 2 times faster than the lock-free implementation. We believe
                    we again benefit from the SIMD and data locality.</p>

<p>Mix Benchmark with
    Thread Num 32
    20 % read, 60 % insert, 20% delete
    total 3,200,000 tasks</p>

                <center>
                    <img src="assets/img/fr9.png" alt="">
                    <br>
                    <b><big>Table 6. Mix Requests Performance Between CStore and Lock-free Skiplist</big></b>
                    <br>
                    (Thread Num 32, Total Tasks = 32,000,000)

                    <br>
                    <br>

                    <img src="assets/img/fr10.jpeg" alt="">
                    <br>
                    <b><big>Figure 6. Mix Requests Performance Between CStore and Lock-free Skiplist</big></b>
                </center>

                For mix test, the result is similar. The lock-free intrinsics are implemented similarly, so CStrore’s speedup benefits from SIMD and data locality.

                <h2 class="text-center">What we hope to achieve on Friday</h2>
                <p>
                    We hope to finely tune our parameters in different testing scenarios so the performance could be
                    even better. We also want to find other lock-free skiplist implementations and do benchmark on them
                </p>

            </div>
        </div>
    </div>
</section>
<!--End About Team Section -->
<!-- Pricing Section -->

<!-- JAVASCRIPT FILES PLACED AT THE BOTTOM TO REDUCE THE LOADING TIME  -->
<!-- CORE JQUERY  -->
<script src="assets/plugins/jquery-1.10.2.js"></script>
<!-- BOOTSTRAP CORE SCRIPT   -->
<script src="assets/plugins/bootstrap.js"></script>
<!-- VEGAS SLIDESHOW SCRIPTS -->
<script src="assets/plugins/vegas/jquery.vegas.min.js"></script>
<!-- CUSTOM SCRIPTS -->
<script src="assets/js/custom.js"></script>
</body>

</html>
