<!DOCTYPE html>
<!--[if lt IE 7 ]>
<html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]>
<html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]>
<html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<html lang="en">
<!--<![endif]-->

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <!--[if IE]>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <![endif]-->
    <title>CStore: In-Memory Column-Oritented Data Store</title>
    <!--REQUIRED STYLE SHEETS-->
    <!-- BOOTSTRAP CORE STYLE CSS -->
    <link href="assets/css/bootstrap.css" rel="stylesheet"/>
    <link href="assets/css/bootflat.css" rel="stylesheet"/>
    <!-- FONTAWESOME STYLE CSS -->
    <link href="assets/css/font-awesome.min.css" rel="stylesheet"/>
    <!-- VEGAS STYLE CSS -->
    <link href="assets/scripts/vegas/jquery.vegas.min.css" rel="stylesheet"/>
    <!-- CUSTOM STYLE CSS -->
    <link href="assets/css/style.css" rel="stylesheet"/>
    <!-- GOOGLE FONT -->
    <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
</head>

<body>
<!--Header section  -->
<div class="container" id="home">
    <div class="row text-center">
        <div class="col-md-12">
            <h1 class="head-main">CStore: A Lock-free SIMD Skip List</h1>
            <h2 class="head-sub-main"></h2>
            <h3 class="head-last"><a href="">Ziyi Liu</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="">Quan Quan</a>
            </h3>
        </div>
    </div>
</div>
<!--End Header section  -->
<!-- Navigation -->
<nav class="navbar-inverse" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="#"> CStore</a>
        </div>
        <!-- Collect the nav links for toggling -->
        <div class="collapse navbar-collapse navbar-ex1-collapse pull-right">
            <ul class="nav navbar-nav">
                <li><a href="proposal.html">Proposal</a>
                </li>
                <!--<li><a href="proposal.html">PROPOSAL</a>-->
                <!--</li>-->
                <!--<li><a href="checkpoint.html">CHECKPOINT</a>-->
                <!--</li>-->
                <li><a href="index.html">FINAL REPORT DRAFT</a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<!--End Navigation -->
<!--About Section-->
<section class="for-full-back color-white " id="about">
    <div class="container introduction">
        <div class="row text-center">
            <div class="col-md-8 col-md-offset-2 ">
                <h1>Final Report Draft</h1>
                <!-- <h4>
                    <strong>
                   Lorem ipsum dolor sit amet, consectetur adipiscing elit.
                     Curabitur nec nisl odio. Mauris vehicula at nunc id posuere.
                        </strong>
                </h4> -->
            </div>
        </div>
        <div class="row g-pad-bottom">
            <div class="col-md-12">
                <h2>Summary</h2>
                <p>
                    In this project we implemented a lock-free skiplist which supports insert, delete and find.
                    It is different from traditional lock-free skiplist in a way that we divide the skiplist into the
                    index layer and storage layer, and apply SIMD to speed up the lookup process.
                </p>

                <img src="assets/img/F1.jpeg" alt="">

                <p>Above is a representation of the architecture of our skiplist. In the index layer, we group multiple
                    indexes of a node together in one index node, so we can make use of cache locality and use SIMD
                    comparison to get the routing decision in one run. The index layer will not change until some upper
                    limit of the number of inserts and deletes are triggered, in which case we will build a new index layer to replace the old one. In the storage layer, we only have an ordered lock-free singly-linked list.
                </p>
                <h2>Challenges</h2>
                <p>1. In order to hava a good perfermance, we need to build a lockfree sorted linkedlist act as the storage layer. We referred to Harris’s solution[1] of a lockfree sorted linkedlist: utilize CAS and a special mark on node’s next address to implement the lockfree insert and lockfree deletion. The last digit of the next pointer is used to mark the node is logical deleted. However, this is not enough in our case. Beside the storage layer, we still have index layer which holds the pointers to the nodes in storage layer. If we physically delete the node after a node is marked logical deleted as described in the paper[1], this will cause unsafe operations. To address this, we introduced another flag which we called it confirm_delete flag. This flag placed on the second last digit of a node’s next pointer. The confirm_delete flag will only be set while rebuilding the new index layer. And after a node is marked as confirm_delete, it will be physically deleted in later operations.
                </p>
                <p>2. For the index layer, because we are grouping multiple indexes on the same level to one single index node, this makes modifying it without using locks to be very hard. This leads us to believe it is better to only build a new index layer and replace the old one at some interval. Although it may hurts the performance a little bit when inserts and deletes are a majority, it saves us the difficulty to build a lock-free index layer (because simply adding a lock or moving data in memory may hurt the performance even further).
                </p>
                <p>3. The index layer rebuilding mechanism introduces a new problem: when shall we delete the old index layer? Because we do not have a way to confirm whether any ongoing query is searching through the index layer. If we are not careful, these queries will throw segmentation faults. To handle this problem, we added a global atomic counter and a per-index-layer atomic counter. As soon as any of the find(), insert() or delete() is entered/leaved, global counter will self-increment/decrement. After the global counter increment, we will save a copy of the pointer to the current index layer and increment that index layer’s counter, and after we are done we decrement it. The pseudo code looks like this:
                </p>
                <img src="assets/img/F2.jpeg" alt="">

                <p>Then in a backend process, we detect if global_counter is equal to the sum of the counter in both the old and new index layers. If it is, then this means no ongoing query is stuck between getting a local copy of the index layer and do something from the index layer, we only need to wait until old index layer’s counter is equal to 0. Then we can safely delete the old index layer. In our testing, atomic integers are very efficient if not highly contended, so it should not hurt the performance much.
                </p>
            </div>
        </div>
    </div>
</section>
<!--End About Section-->
<!-- About Team Section -->
<section class="for-full-back color-light challenge" id="about-team">
    <div class="container">
        <div class="row introduction">
            <div class="col-md-12">
                <h2 class="text-center">Results</h2>

                <p>
                    Until now we still have minor bugs in our deletion part, but we are confident to fix them and begin profiling tonight. For read-only scenario, we have the following result compared to std::map (red-black tree, not thread-safe) and normal skiplist (not thread-safe):
                </p>

                <img src="assets/img/F3.jpeg" alt="">

                <br>
                <br>

                <img src="assets/img/F4.jpeg" alt="">


                <p>
                    We can see from the benchmark that if not adding lock to the std::map(), it generally is 2~3 times faster than our implementation. Because we are making use of data locality and SIMD comparison, we are far faster than sequential skiplist even the latter is not using a lock. We expect our solution to be faster than std::map with a lock.

                </p>

                <h2 class="text-center">What we hope to achieve on Friday</h2>
                <p>
                    We hope to benchmark the performance under different workload (mix of insert, delete and find) and see a good speedup from std::map with a lock under read-heavy scenario.
                </p>

            </div>
        </div>
    </div>
</section>
<!--End About Team Section -->
<!-- Pricing Section -->

<!-- JAVASCRIPT FILES PLACED AT THE BOTTOM TO REDUCE THE LOADING TIME  -->
<!-- CORE JQUERY  -->
<script src="assets/plugins/jquery-1.10.2.js"></script>
<!-- BOOTSTRAP CORE SCRIPT   -->
<script src="assets/plugins/bootstrap.js"></script>
<!-- VEGAS SLIDESHOW SCRIPTS -->
<script src="assets/plugins/vegas/jquery.vegas.min.js"></script>
<!-- CUSTOM SCRIPTS -->
<script src="assets/js/custom.js"></script>
</body>

</html>
